# 逃逸分析

## 1. 生命周期变长

当局部变量不应随着栈的缩减而回收（被外部引用），而使得变量声明周期变长,会发生逃逸
[代码示例](./example/1/main.go)

```go{.line-numbers}
package main

type A struct {
 Name string
}

func NewAP(name string) *A {
 return &A{Name: name}
}

func NewA(name string) A {
 return A{Name: name}
}

func main() {
 NewAP("golang")
 NewA("golang")
}

// go build -gcflags '-m -l' .\example\1\main.go
// # command-line-arguments
// example\1\main.go:7:12: leaking param: name
// example\1\main.go:8:9: &A{...} escapes to heap # 返回A的指针，被mian（）使用 逃逸
// example\1\main.go:11:11: leaking param: name to result ~r1 level=0
```

验证

```go
// go tool compile -S .\example\1\main.go
"".NewAP STEXT size=117 args=0x18 locals=0x18 funcid=0x0
  ······
        0x0024 00036 (.\example\1\main.go:8)    LEAQ    type."".A(SB), AX
        0x002b 00043 (.\example\1\main.go:8)    MOVQ    AX, (SP)
        0x002f 00047 (.\example\1\main.go:8)    PCDATA  $1, $0
        0x002f 00047 (.\example\1\main.go:8)    CALL    runtime.newobject(SB) #在堆上创建对象
        0x0034 00052 (.\example\1\main.go:8)    MOVQ    8(SP), DI
        0x0039 00057 (.\example\1\main.go:8)    MOVQ    "".name+40(SP), AX
        0x003e 00062 (.\example\1\main.go:8)    MOVQ    AX, 8(DI)
        0x0042 00066 (.\example\1\main.go:8)    PCDATA  $0, $-2
        0x0042 00066 (.\example\1\main.go:8)    CMPL    runtime.writeBarrier(SB)
  ·····
```

## 2.栈空间大小不足

当对象大小不可预期，或者超过一定大小的局部变量会发生逃逸
[代码示例](./example/2/main.go)

```go{.line-numbers}
package main

func f(n int)int{
 a := make([]int,n)
 l:=len(a)
 return l
}

func main() {
 a := [13107200]int64{}
 a[0]=0
 b := [131072]int64{}
 b[0]=0
 f(100)
}
// go build -gcflags '-m -l' .\example\2\main.go
// # command-line-arguments
// example\2\main.go:4:11: make([]int, n) escapes to heap # 大小不可预期，逃逸
// example\2\main.go:10:2: moved to heap: a # 超过一定大小，逃逸
```

大小的界定不同版本不同系统都可能有所不同

## 3. 性能相关

传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。
