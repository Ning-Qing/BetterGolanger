# 树
## 字典树

```
单词的压缩编码
单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：

words.length == indices.length
助记字符串 s 以 '#' 字符结尾
对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 '#' 字符结束（但不包括 '#'）的 子字符串 恰好与 words[i] 相等
给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。

 

示例 1：

输入：words = ["time", "me", "bell"]
输出：10
解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。
words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
示例 2：

输入：words = ["t"]
输出：2
解释：一组有效编码为 s = "t#" 和 indices = [0] 。
 
```

>  思路

目标保留所有不是其他单词后缀的单词。

>  算法

去找到是否不同的单词具有相同的后缀，我们可以将其反序之后插入字典树中。例如，我们有 "time" 和 "me"，可以将 "emit" 和 "em" 插入字典树中。然后，字典树的叶子节点（没有孩子的节点）就代表没有后缀的单词，统计叶子节点代表的单词长度加一的和即为我们要的答案。	

![image.png](https://pic.leetcode-cn.com/22975162d4df780a94bfe38c79f72f9bca39e9083f08008b8a279d9f82a3e82f-image.png)

```go
type node struct {
	isStr bool
	next  []*node
}

func NewTree() *node {
	return &node{
		isStr: false,
		next:  make([]*node, 26),
	}
}

func insert(root *node, str string) {
	for i := len(str) - 1; i >= 0; i-- {
		if root.next[str[i]-'a'] == nil {
			root.next[str[i]-'a'] = &node{
				isStr: i == 0,
				next:  make([]*node, 26),
			}
		}
		root = root.next[str[i]-'a']
	}
}

func findLeaf(root *node, length int) int {
	var (
		isLeaf = true
		sum    = 0
	)
	nodes := root.next
	for i := 0; i < 26; i++ {
		if nodes[i] != nil {
			isLeaf = false
			sum += FindLeaf(nodes[i], length+1)
		}
	}
	if isLeaf {
		return length + 1
	}
	return sum
}

func minimumLengthEncoding(words []string) int {
	var (
		root = NewTree()
	)
	for i := 0; i < len(words); i++ {
		temp := words[i]
		insert(root, temp)
	}
	return findLeaf(root, 0)
}

```

