# 哈希表
```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
 

提示:

1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-anagram
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}
	// 小写英文字符26个
	// 从0逐个映射 0->a
	arr := [26]int{}
	for i:=0;i<len(s);i++{
		// [s[i]-'a'] 借用ASCII编码映射
		arr[s[i]-'a']++
		arr[t[i]-'a']--
	}
	for _,v:=range arr{
		if v !=0{
			return false
		}
	}
	return true
}
```
```
给定两个数组，编写一个函数来计算它们的交集。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 

说明：

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func intersection(nums1 []int, nums2 []int) []int {
	m := make(map[int]int)
	for _,v := range nums1{
		m[v]=1
	}
	for _,v := range nums2{
		if _,ok:=m[v];ok{
			m[v]++
		}
	}
	res := make([]int,0)
	for k,v:=range m{
		if v>1{
			res=append(res,k)
		}
	}
	return res
}
```
```
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

 

示例 1：

输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false
 

提示：

1 <= n <= 231 - 1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/happy-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
因为这个过程也可能是无限循环始终变不到1,所以一定会有各位平方和的结果会重复出现
```go
func getSum(n int)int{
	res :=0
	for n >0 {
		res +=(n%10)*(n%10)
		n/=10
	}
	return res
}

func isHappy(n int) bool {
	m := make(map[int]int)
	for sum:=getSum(n);sum!=1;sum=getSum(sum){
		if _,ok := m[sum];ok{
			return false
		}else{
			m[sum]=0
		}
	}
	return true
}
```
```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
 

提示：

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func twoSum(nums []int, target int) []int {
    hashTable := map[int]int{}
    for i, x := range nums {
        if p, ok := hashTable[target-x]; ok {
            return []int{p, i}
        }
        hashTable[x] = i
    }
    return nil
}
```
```
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。

例如:

输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/4sum-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
四个数之和，相当于两个两个数之和
```
func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {
	count :=0
	map1:=make(map[int]int)
	for _,v1 := range nums1{
		for _,v2 := range nums2{
			value := v1+v2
			if _,ok:=map1[value];!ok{
				map1[value]=1
			}else{
				map1[value]+=1
			}
		}
	}

	for _,v1 := range nums3{
		for _,v2 := range nums4{
			value := v1+v2
			if _,ok:=map1[-value];ok{
				count += map1[-value]
			}
		}
	}

	return count
}
```
```
给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

 

示例 1：

输入：ransomNote = "a", magazine = "b"
输出：false
示例 2：

输入：ransomNote = "aa", magazine = "ab"
输出：false
示例 3：

输入：ransomNote = "aa", magazine = "aab"
输出：true
 

提示：

你可以假设两个字符串均只含有小写字母。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ransom-note
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func canConstruct(ransomNote string, magazine string) bool {
	if len(ransomNote)>len(magazine){
		return false
	}

	// 使用数组以节约空间
	hashMap :=[26]int{0}

	for _,v :=range magazine{
		hashMap[v-'a']+=1
	}

	for _,v :=range ransomNote{
		if hashMap[v-'a']-=1;hashMap[v-'a']<0{
			return false
		}
	}

	return true
}
```