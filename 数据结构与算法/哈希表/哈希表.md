# 哈希表
```
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

 

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
 

提示:

1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-anagram
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func isAnagram(s string, t string) bool {
	if len(s) != len(t) {
		return false
	}
	// 小写英文字符26个
	// 从0逐个映射 0->a
	arr := [26]int{}
	for i:=0;i<len(s);i++{
		// [s[i]-'a'] 借用ASCII编码映射
		arr[s[i]-'a']++
		arr[t[i]-'a']--
	}
	for _,v:=range arr{
		if v !=0{
			return false
		}
	}
	return true
}
```
```
给定两个数组，编写一个函数来计算它们的交集。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 

说明：

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func intersection(nums1 []int, nums2 []int) []int {
	m := make(map[int]int)
	for _,v := range nums1{
		m[v]=1
	}
	for _,v := range nums2{
		if _,ok:=m[v];ok{
			m[v]++
		}
	}
	res := make([]int,0)
	for k,v:=range m{
		if v>1{
			res=append(res,k)
		}
	}
	return res
}
```
```
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

 

示例 1：

输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false
 

提示：

1 <= n <= 231 - 1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/happy-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
因为这个过程也可能是无限循环始终变不到1,所以一定会有各位平方和的结果会重复出现
```go
func getSum(n int)int{
	res :=0
	for n >0 {
		res +=(n%10)*(n%10)
		n/=10
	}
	return res
}

func isHappy(n int) bool {
	m := make(map[int]int)
	for sum:=getSum(n);sum!=1;sum=getSum(sum){
		if _,ok := m[sum];ok{
			return false
		}else{
			m[sum]=0
		}
	}
	return true
}
```