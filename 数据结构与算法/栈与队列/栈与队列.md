# 栈与队列
```
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
 

说明：

你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 

进阶：

你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
 

示例：

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
 

提示：

1 <= x <= 9
最多调用 100 次 push、pop、peek 和 empty
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-queue-using-stacks
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
用两个栈可实现有先进后出到先进先出
```go
type MyQueue struct {
	inStack,outStack []int
}


/** Initialize your data structure here. */
func Constructor() MyQueue {
	return MyQueue{inStack:make([]int,0,100),outStack:make([]int,0,100)}
}


/** Push element x to the back of queue. */
func (this *MyQueue) Push(x int)  {
	this.inStack = append(this.inStack,x)
}

func (this *MyQueue) inToOut(){
	for len(this.inStack)>0{
		this.outStack = append(this.outStack,this.inStack[len(this.inStack)-1])
		this.inStack = this.inStack[:len(this.inStack)-1]
	}	
}

/** Removes the element from in front of queue and returns that element. */
func (this *MyQueue) Pop() int {
	// 当outStack为空，将inStack数据依次出栈放入outStack
	if len(this.outStack)==0{
			this.inToOut()
	}
	// 此时outStack是inStack的逆序
	res := this.outStack[len(this.outStack)-1]
	this.outStack = this.outStack[:len(this.outStack)-1]
	return res
}


/** Get the front element. */
func (this *MyQueue) Peek() int {
	if len(this.outStack)==0{
		this.inToOut()
	}
	return this.outStack[len(this.outStack)-1]
}


/** Returns whether the queue is empty. */
func (this *MyQueue) Empty() bool {
	return len(this.inStack)==0 && len(this.outStack)==0
}
```

```
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 

注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 

示例：

输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
 

提示：

1 <= x <= 9
最多调用100 次 push、pop、top 和 empty
每次调用 pop 和 top 都保证栈不为空
 

进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-stack-using-queues
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
用两个队列来实现栈，一个队列用来存储后入数据，一个队列用来存储先入数据，
然后将先入数据放入后入数据队列
```go
type MyStack struct {
	queue1,queue2 []int
}


/** Initialize your data structure here. */
func Constructor() MyStack {
	return MyStack{queue1:make([]int,0,100),queue2:make([]int,0,100)}
}


/** Push element x onto stack. */
func (this *MyStack) Push(x int)  {
	// 此时queue1存了所有数，queue2为空
	// 后入 如果要先出 就需要将其他数堆在它后面
	this.queue2 = append(this.queue2,x)
	// 将其他数堆在后面，queue2存了所有数，queue1 为空
	for len(this.queue1)>0 {
		this.queue2 = append(this.queue2,this.queue1[0])
		this.queue1 = this.queue1[1:]
	}
	// 交换,恢复成初始状态
	this.queue2,this.queue1 =this.queue1,this.queue2
}


/** Removes the element on top of the stack and returns that element. */
func (this *MyStack) Pop() int {
	res := this.queue1[0]
	this.queue1=this.queue1[1:]
	return res
}


/** Get the top element. */
func (this *MyStack) Top() int {
	return this.queue1[0]
}


/** Returns whether the stack is empty. */
func (this *MyStack) Empty() bool {
	return len(this.queue1)==0
}
```
```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
 

示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false
示例 4：

输入：s = "([)]"
输出：false
示例 5：

输入：s = "{[]}"
输出：true
 

提示：

1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-parentheses
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func isValid(s string) bool {
	m :=map[byte]byte{
		')':'(',
		']':'[',
		'}':'{',
	}
	b := []byte(s)
	stack := make([]byte,0,len(s))
	for len(b)>0{
		char := b[len(b)-1]
		if len(stack)==0 || m[stack[len(stack)-1]]!=char{
			stack=append(stack,char)
			b = b[:len(b)-1]
		}else{
			stack=stack[:len(stack)-1]
			b = b[:len(b)-1]
		}
	}
	if len(stack)==0&&len(b)==0{
		return true
	}
	return false
}
```
```
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
 

提示：

1 <= S.length <= 20000
S 仅由小写英文字母组成

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func removeDuplicates(s string) string {
	stack := make([]byte, 0, len(s))
	b := []byte(s)
	for _, v := range b {
		if len(stack) == 0 || v != stack[len(stack)-1] {
			stack = append(stack, v)

		} else {
			stack = stack[:len(stack)-1]
		}

	}
	return string(stack)
}
```
```
根据 逆波兰表示法，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

 

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
 

示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
 

提示：

1 <= tokens.length <= 104
tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数
 

逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func evalRPN(tokens []string) int {
	stack := make([]int, 0, len(tokens))
	for _, v := range tokens {
		switch v {
		case "+":
			b := stack[len(stack)-1]
			a := stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			stack = append(stack, a+b)
		case "-":
			b := stack[len(stack)-1]
			a := stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			stack = append(stack, a-b)
		case "*":
			b := stack[len(stack)-1]
			a := stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			stack = append(stack, a*b)
		case "/":
			b := stack[len(stack)-1]
			a := stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			stack = append(stack, a/b)
		default:
			value, _ := strconv.Atoi(v)
			stack = append(stack, value)
		}	
	}
	return stack[len(stack)-1]
}
```
## 单调队列
```
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]
示例 3：

输入：nums = [1,-1], k = 1
输出：[1,-1]
示例 4：

输入：nums = [9,11], k = 2
输出：[11]
示例 5：

输入：nums = [4,-2], k = 2
输出：[4]
 

提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sliding-window-maximum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
func maxSlidingWindow(nums []int, k int) []int {
	// 构建单调递减队列
	queue := make([]int,0,len(nums))
	push := func(value int){
		// 入队时如若要保持单调性
		// 应拿入队元素和队列末端元素比较
		// 如果大于，则将末端元素弹出
		// 直到入队元素小于末端元素
		for len(queue) != 0&&value>queue[len(queue)-1]{
			queue = queue[:len(queue)-1]
		}
		queue =append(queue,value)
	}
	pop := func(value int){
		if len(queue) != 0&&value == queue[0]{
			queue = queue[1:]
		}
	}

	for i:=0;i<k;i++{
		push(nums[i])
	}
	res := make([]int,0,len(nums))
	res=append(res,queue[0])
	for i:=k;i<len(nums);i++{
		pop(nums[i-k])
		push(nums[i])
		res = append(res,queue[0])
	}
	return res
}
```
## 优先队列
```
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]
 

提示：

1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
 

进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/top-k-frequent-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```
```go
type Heap struct {
	d []data
}

type data struct {
	key   int
	value int
}

func (h Heap) Len() int {
	return len(h.d)
}

func (h *Heap) Swap(i, j int) {
	h.d[i], h.d[j] = h.d[j], h.d[i]
}

func (h Heap) Less(i, j int) bool {
	return h.d[i].value < h.d[j].value
}

func (h *Heap) Pop() interface{} {
	back := h.d[len(h.d)-1]
	h.d = h.d[:len(h.d)-1]
	return back
}

func (h *Heap) Push(x interface{}) {
	h.d = append(h.d, x.(data))
}

func topKFrequent(nums []int, k int) []int {
	m := make(map[int]int)
	for _, v := range nums {
		m[v]++
	}

	h := &Heap{d:make([]data,0,k+1)}
	heap.Init(h)
	for key, value := range m {
		heap.Push(h,data{key: key, value: value})
		for h.Len() > k {
			heap.Pop(h)
		}
	}
	res := make([]int,0,k)
	for i:=0;i<k;i++{
		res = append(res, heap.Pop(h).(data).key)
	}
	return res
}
```